package smartssh

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"net"
	"os"
	"strings"

	"golang.org/x/crypto/ssh"
)

type Listener struct {
	tl     net.Listener
	config Config
}

type Config struct {
	// password callback function
	// nil to disable auth
	PasswordCheck func(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error)

	// limit of auth tries before connection drop
	// default or 0 set amount to 6
	MaxAuthTries int

	// must start with "SSH-2.0-" string because of RFC 4253
	ServerVersion string

	// banner which shown before authentication
	Banner string
}

type Conn struct {
}

// read key from file
// or generate it if file doesn't exist
func ReadKey(filename string) (ssh.Signer, error) {
	keyBytes, err := os.ReadFile(filename)
	if err != nil {
		if os.IsNotExist(err) {
			rsaKey, err := rsa.GenerateKey(rand.Reader, 2048)
			if err != nil {
				return nil, err
			}
			pemBlock := &pem.Block{
				Type:  "RSA PRIVATE KEY",
				Bytes: x509.MarshalPKCS1PrivateKey(rsaKey),
			}
			err = os.WriteFile(filename, pem.EncodeToMemory(pemBlock), 0600)
			return ssh.NewSignerFromKey(rsaKey)
		} else {
			return nil, err
		}
	}
	keyBytes = []byte(strings.TrimSpace(string(keyBytes)))
	return ssh.ParsePrivateKey(keyBytes)
}

// set key to nil for autogenerated pem file
func Listen(host string, key ssh.Signer, config Config) (*Listener, error) {
	if key == nil {
		var err error
		key, err = ReadKey(".takataka.pem")
		if err != nil {
			return nil, err
		}
	}
	tcpListener, err := net.Listen("tcp", host)
	if err != nil {
		return nil, err
	}
	return &Listener{
		tl:     tcpListener,
		config: config,
	}, nil
}

func (l *Listener) Accept() (*Conn, error) {
	tl := l.tl
	tc, err := tl.Accept()
	if err != nil {
		return nil, err
	}
	config := &ssh.ServerConfig{
		PasswordCallback: l.config.PasswordCheck,
		NoClientAuth:     l.config.PasswordCheck == nil,
		MaxAuthTries:     l.config.MaxAuthTries,
		ServerVersion:    l.config.ServerVersion,
		BannerCallback:   func(conn ssh.ConnMetadata) string { return l.config.Banner },
	}
	sshConn, chans, reqs, err := ssh.NewServerConn(tc)
}
